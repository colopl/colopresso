name: CI

on:
  push:
    branches:
      - main
  pull_request:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  Prepare:
    runs-on: ubuntu-latest
    outputs:
      emsdk_version: ${{ steps.get_emsdk_version.outputs.emsdk_version }}
      rust_stable: ${{ steps.get_rust_versions.outputs.rust_stable }}
      rust_nightly: ${{ steps.get_rust_versions.outputs.rust_nightly }}
      wasm_pack_version: ${{ steps.get_rust_versions.outputs.wasm_pack_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          submodules: true
          fetch-depth: 1
      - name: EMSDK require full checkout
        id: get_emsdk_version
        working-directory: "third_party/emsdk"
        run: |
          git fetch --tags
          echo "emsdk_version=$(git describe --tags --abbrev=0)" >> "${GITHUB_OUTPUT}"
      - name: Get Rust versions from rust-toolchain.toml
        id: get_rust_versions
        run: |
          RUST_STABLE=$(grep -E '^channel\s*=' rust-toolchain.toml | sed 's/.*=\s*"\([^"]*\)".*/\1/')
          RUST_NIGHTLY=$(grep -E '^nightly\s*=' rust-toolchain.toml | sed 's/.*=\s*"\([^"]*\)".*/\1/')
          WASM_PACK=$(grep -E '^wasm-pack\s*=' rust-toolchain.toml | sed 's/.*=\s*"\([^"]*\)".*/\1/')
          echo "rust_stable=${RUST_STABLE}" >> "${GITHUB_OUTPUT}"
          echo "rust_nightly=${RUST_NIGHTLY}" >> "${GITHUB_OUTPUT}"
          echo "wasm_pack_version=${WASM_PACK}" >> "${GITHUB_OUTPUT}"
      - name: Dummy versioning
        run: |
          sed -i "s|/\* COLOPL_VERSION_START \*/.*/\* COLOPL_VERSION_END \*/|999999998|" "library/include/colopresso.h"
          sed -i "s|VERSION 0.0.0|VERSION 999.999.998|" "CMakeLists.txt"
          sed -i "s|0.0.0|999.999.998|" "app/chrome/manifest.json"
          sed -i 's|"version": "0.0.0"|"version": "999.999.998"|' "package.json"
      - name: Tar dummy versioned code
        run: |
          tar -czf "../dummy-versioned-code.tar.gz" -C .. "$(basename "${PWD}")"
          mv "../dummy-versioned-code.tar.gz" "./dummy-versioned-code.tar.gz"
      - name: Upload versioned code
        uses: actions/upload-artifact@v7
        with:
          name: dummy-versioned-code
          path: ./dummy-versioned-code.tar.gz
          retention-days: 1
  LinuxAndChromeExtension:
    needs: Prepare
    strategy:
      matrix:
        include:
          - arch: amd64
            platform: linux/amd64
            runs-on: ubuntu-24.04
          - arch: arm64
            platform: linux/arm64
            runs-on: ubuntu-24.04-arm
    runs-on: ${{ matrix.runs-on }}
    steps:
      - name: Download dummy versioned code
        uses: actions/download-artifact@v8
        with:
          name: dummy-versioned-code
          path: .
      - name: Extract dummy versioned code
        run: |
          tar -xzf "dummy-versioned-code.tar.gz" --strip-components=1
          rm -rf "dummy-versioned-code.tar.gz"
      - name: Build container
        run: |
          docker build \
            --file "Dockerfile" \
            --build-arg PLATFORM="${{ matrix.platform }}" \
            --build-arg ENABLE_VALGRIND="0" \
            --build-arg ENABLE_CLANG="1" \
            --build-arg ENABLE_EMSDK="1" \
            --build-arg EMSDK_VERSION="${{ needs.Prepare.outputs.emsdk_version }}" \
            --target "builder" \
            --tag "ci" \
            .
      - name: Build and test on container
        run: |
          docker run \
            --rm \
            --volume "${PWD}:/workspace" \
            --workdir "/workspace" \
            ci \
            /bin/bash -lc '
              set -e

              rm -rf "build"
              cmake -B "build" \
                -DCMAKE_BUILD_TYPE="Release" \
                -DCOLOPRESSO_USE_TESTS=ON \
                -DCOLOPRESSO_USE_UTILS=ON \
                -DCOLOPRESSO_USE_CLI=ON
              cmake --build "build" --config "Release" --parallel="$(($(nproc)-1))"
              ctest --test-dir "build" --output-on-failure --parallel

              for OPTS in ASAN MSAN UBSAN; do
                rm -rf "build"
                cmake -B "build" \
                  -DCMAKE_C_COMPILER="$(command -v "clang")" \
                  -DCMAKE_CXX_COMPILER="$(command -v "clang++")" \
                  -DCMAKE_BUILD_TYPE="Debug" \
                  -DCOLOPRESSO_USE_TESTS=ON \
                  -DCOLOPRESSO_USE_UTILS=ON \
                  -DCOLOPRESSO_USE_CLI=ON \
                  -DCOLOPRESSO_USE_${OPTS}=ON
                cmake --build "build" --config "Debug" --parallel="$(($(nproc)-1))"
                ctest --test-dir "build" --output-on-failure --parallel
              done

              rm -rf "build"
              emcmake cmake -B "build" \
                -DCMAKE_BUILD_TYPE="Release" \
                -DCOLOPRESSO_NODE_BUILD=ON \
                -DCOLOPRESSO_USE_TESTS=ON \
                -DCOLOPRESSO_USE_UTILS=ON \
                -DCOLOPRESSO_USE_CLI=ON
              cmake --build "build" --config "Release" --parallel="$(($(nproc)-1))"
              ctest --test-dir "build" --output-on-failure --parallel

              rm -rf "build"
              emcmake cmake -B "build" \
                -DCMAKE_BUILD_TYPE="Release" \
                -DCOLOPRESSO_CHROME_EXTENSION=ON
              cmake --build "build" --config "Release" --parallel="$(($(nproc)-1))"
            '
  Valgrind:
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    needs: Prepare
    strategy:
      matrix:
        include:
          - arch: amd64
            platform: linux/amd64
            runs-on: ubuntu-24.04
          - arch: arm64
            platform: linux/arm64
            runs-on: ubuntu-24.04-arm
    runs-on: ${{ matrix.runs-on }}
    steps:
      - name: Download dummy versioned code
        uses: actions/download-artifact@v8
        with:
          name: dummy-versioned-code
          path: .
      - name: Extract dummy versioned code
        run: |
          tar -xzf "dummy-versioned-code.tar.gz" --strip-components=1
          rm -rf "dummy-versioned-code.tar.gz"
      - name: Build container
        run: |
          docker build \
            --file "Dockerfile" \
            --build-arg PLATFORM="${{ matrix.platform }}" \
            --build-arg ENABLE_VALGRIND="1" \
            --build-arg ENABLE_CLANG="0" \
            --build-arg ENABLE_EMSDK="0" \
            --target "builder" \
            --tag "valgrind" \
            .
      - name: Run Valgrind tests
        run: |
          docker run \
            --rm \
            --volume "${PWD}:/workspace" \
            --workdir "/workspace" \
            valgrind \
            /bin/bash -lc '
              set -e
              cmake -B "build" \
                -DCMAKE_BUILD_TYPE="Debug" \
                -DCOLOPRESSO_USE_VALGRIND=ON \
                -DCOLOPRESSO_USE_TESTS=ON \
                -DCOLOPRESSO_USE_UTILS=ON \
                -DCOLOPRESSO_USE_CLI=ON
              cmake --build "build" --config "Debug" --parallel="$(($(nproc)-1))"
              ctest --test-dir "build" --output-on-failure --parallel
            '
  WindowsElectron:
    needs: Prepare
    runs-on: windows-latest
    steps:
      - name: Download dummy versioned code
        uses: actions/download-artifact@v8
        with:
          name: dummy-versioned-code
      - name: Extract versioned code
        run: |
          tar -xzf "dummy-versioned-code.tar.gz" --strip-components=1
          Remove-Item "dummy-versioned-code.tar.gz" -Force
      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0
        with:
          version: 10
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '24'
          cache: 'pnpm'
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@efa25f7f19611383d5b0ccf2d1c8914531636bf9
        with:
          toolchain: ${{ needs.Prepare.outputs.rust_nightly }}
          targets: wasm32-unknown-emscripten,wasm32-unknown-unknown
          components: rust-src
      - name: Set Rust default
        run: rustup default ${{ needs.Prepare.outputs.rust_nightly }}
      - name: Setup wasm-pack
        run: cargo install "wasm-pack" --version "${{ needs.Prepare.outputs.wasm_pack_version }}" --locked
      - name: Setup emsdk
        shell: pwsh
        working-directory: "third_party/emsdk"
        run: |
          ./emsdk.ps1 install "${{ needs.Prepare.outputs.emsdk_version }}"
          ./emsdk.ps1 activate "${{ needs.Prepare.outputs.emsdk_version }}"
          . "./emsdk_env.ps1"
          Get-ChildItem env: | Where-Object { $_.Name -match '^(EMSDK|EM_|BINARYEN)' } | ForEach-Object {
            "$($_.Name)=$($_.Value)" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          }
          "$env:EMSDK" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          "$env:EMSDK\upstream\emscripten" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          "$env:EMSDK\node\$(Get-ChildItem "$env:EMSDK\node" | Select-Object -First 1 -ExpandProperty Name)_64bit\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
      - name: Build Electron app
        shell: pwsh
        run: |
          emcmake cmake -B "build" -DCOLOPRESSO_ELECTRON_APP=ON -DCOLOPRESSO_ELECTRON_TARGETS="--win"
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
          cmake --build "build" --config "Release" --parallel
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  macOSElectron:
    needs: Prepare
    runs-on: macos-latest
    steps:
      - name: Download dummy versioned code
        uses: actions/download-artifact@v8
        with:
          name: dummy-versioned-code
          path: .
      - name: Extract dummy versioned code
        run: |
          tar -xzf "dummy-versioned-code.tar.gz" --strip-components=1
          rm -rf "dummy-versioned-code.tar.gz"
      - name: Install LLVM (for wasm32 targets)
        run: brew install "llvm"
      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0
        with:
          version: 10
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '24'
          cache: 'pnpm'
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@efa25f7f19611383d5b0ccf2d1c8914531636bf9
        with:
          toolchain: ${{ needs.Prepare.outputs.rust_nightly }}
          targets: wasm32-unknown-emscripten,wasm32-unknown-unknown
          components: rust-src
      - name: Set Rust default
        run: rustup default ${{ needs.Prepare.outputs.rust_nightly }}
      - name: Setup wasm-pack
        run: cargo install "wasm-pack" --version "${{ needs.Prepare.outputs.wasm_pack_version }}" --locked
      - name: Setup emsdk
        working-directory: "third_party/emsdk"
        run: |
          ./emsdk install "${{ needs.Prepare.outputs.emsdk_version }}"
          ./emsdk activate "${{ needs.Prepare.outputs.emsdk_version }}"
          . "./emsdk_env.sh"
          env | grep -E '^(EMSDK|EM_|BINARYEN)' | while IFS='=' read -r KEY VALUE; do
            echo "${KEY}=${VALUE}" >> "${GITHUB_ENV}"
          done
          echo "${EMSDK}" >> "${GITHUB_PATH}"
          echo "${EMSDK}/upstream/emscripten" >> "${GITHUB_PATH}"
          echo "${EMSDK}/node/$(ls "${EMSDK}/node" | head -n 1)_64bit/bin" >> "${GITHUB_PATH}"
      - name: Build Electron app
        run: |
          emcmake cmake -B "build" -DCOLOPRESSO_ELECTRON_APP=ON -DCOLOPRESSO_ELECTRON_TARGETS="--mac"
          cmake --build "build" --config "Release" --parallel
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  WindowsCLI:
    needs: Prepare
    runs-on: windows-latest
    steps:
      - name: Download dummy versioned code
        uses: actions/download-artifact@v8
        with:
          name: dummy-versioned-code
      - name: Extract versioned code
        run: |
          tar -xzf "dummy-versioned-code.tar.gz" --strip-components=1
          Remove-Item "dummy-versioned-code.tar.gz" -Force
      - name: Configure CMake
        run: cmake -B build -DCMAKE_BUILD_TYPE="Release" -DCOLOPRESSO_USE_CLI=ON -DCOLOPRESSO_USE_TESTS=ON
      - name: Build
        run: cmake --build "build" --config "Release" --parallel
      - name: Test
        run: ctest --test-dir "build" --build-config "Release" --output-on-failure --parallel
      - name: Test CLI
        run: build\cli\Release\colopresso.exe --version
  macOSCLI:
    needs: Prepare
    strategy:
      matrix:
        arch:
          - name: apple_silicon
            rust_target: aarch64-apple-darwin
            runs-on: macos-15
          - name: intel
            rust_target: x86_64-apple-darwin
            runs-on: macos-15-intel
    runs-on: ${{ matrix.arch.runs-on }}
    steps:
      - name: Download dummy versioned code
        uses: actions/download-artifact@v8
        with:
          name: dummy-versioned-code
          path: .
      - name: Extract dummy versioned code
        run: |
          tar -xzf "dummy-versioned-code.tar.gz" --strip-components=1
          rm -rf "dummy-versioned-code.tar.gz"
      - name: Configure CMake
        run: |
          cmake -B build \
            -DCMAKE_BUILD_TYPE="Release" \
            -DCOLOPRESSO_USE_CLI=ON \
            -DCOLOPRESSO_USE_TESTS=ON \
            ${{ matrix.arch.name == 'intel' && '-DAOM_TARGET_CPU="generic"' || '' }}
      - name: Build
        run: cmake --build "build" --config "Release" --parallel
      - name: Test
        run: ctest --test-dir "build" --output-on-failure --parallel
      - name: Test CLI
        run: ./build/cli/colopresso --version
  LinuxCLI:
    needs: Prepare
    strategy:
      matrix:
        include:
          - arch: amd64
            runs-on: ubuntu-24.04
          - arch: arm64
            runs-on: ubuntu-24.04-arm
    runs-on: ${{ matrix.runs-on }}
    steps:
      - name: Download dummy versioned code
        uses: actions/download-artifact@v8
        with:
          name: dummy-versioned-code
          path: .
      - name: Extract dummy versioned code
        run: |
          tar -xzf "dummy-versioned-code.tar.gz" --strip-components=1
          rm -rf "dummy-versioned-code.tar.gz"
      - name: Build container
        run: |
          docker build \
            --file "Dockerfile.alpine" \
            --tag "cli" \
            .
      - name: Build CLI in container
        run: |
          docker run \
            --rm \
            --volume "${PWD}:/workspace" \
            --workdir "/workspace" \
            "cli" \
            /bin/sh -c '
              set -e
              cmake -B build \
                -DCMAKE_BUILD_TYPE="Release" \
                -DCMAKE_EXE_LINKER_FLAGS="-static" \
                -DCOLOPRESSO_USE_CLI=ON \
                -DCOLOPRESSO_USE_TESTS=ON
              cmake --build "build" --config "Release" --target "colopresso_cli" --parallel="$(($(nproc)-1))"
              strip build/cli/colopresso
              build/cli/colopresso --version
              build/cli/colopresso --verbose --format=webp assets/example.png "/tmp/example.webp"
              build/cli/colopresso --verbose --format=avif assets/example.png "/tmp/example.avif"
              build/cli/colopresso --verbose --format=pngx assets/example.png "/tmp/example.png"
            '
      - name: Test binary in minimal container
        run: |
          docker run \
            --rm \
            --volume "${PWD}/build/cli/colopresso:/colopresso:ro" \
            --volume "${PWD}/assets:/assets:ro" \
            alpine:latest \
            /bin/sh -c '
              set +e
              /colopresso --verbose --format=pngx "/assets/increase.png" "/tmp/increase.png"
              EXIT_CODE=$?
              if test ${EXIT_CODE} -ne 2; then
                echo "Error: Expected exit code 2, got ${EXIT_CODE}"
                exit 1
              fi

              set -e
              /colopresso --version
              /colopresso --verbose --format=webp "/assets/example.png" "/tmp/example.webp"
              /colopresso --verbose --format=avif "/assets/example.png" "/tmp/example.avif"
              /colopresso --verbose --format=pngx "/assets/example.png" "/tmp/example.png"
            '
          docker run \
            --rm \
            --volume "${PWD}/build/cli/colopresso:/colopresso:ro" \
            --volume "${PWD}/assets:/assets:ro" \
            busybox:musl \
            /bin/sh -c '
              set +e
              /colopresso --verbose --format=pngx "/assets/increase.png" "/tmp/increase.png"
              EXIT_CODE=$?
              if test ${EXIT_CODE} -ne 2; then
                echo "Error: Expected exit code 2, got ${EXIT_CODE}"
                exit 1
              fi

              set -e
              /colopresso --version
              /colopresso --verbose --format=webp "/assets/example.png" "/tmp/example.webp"
              /colopresso --verbose --format=avif "/assets/example.png" "/tmp/example.avif"
              /colopresso --verbose --format=pngx "/assets/example.png" "/tmp/example.png"
            '
  PythonWheel:
    needs: Prepare
    strategy:
      matrix:
        include:
          - os: linux
            arch: amd64
            runs-on: ubuntu-24.04
            cibw_archs_linux: x86_64
          - os: linux
            arch: arm64
            runs-on: ubuntu-24.04-arm
            cibw_archs_linux: aarch64
          - os: windows
            arch: amd64
            runs-on: windows-latest
            cibw_archs_windows: AMD64
          - os: macos
            arch: amd64
            runs-on: macos-15-intel
            cibw_archs_macos: x86_64
          - os: macos
            arch: arm64
            runs-on: macos-15
            cibw_archs_macos: arm64
    runs-on: ${{ matrix.runs-on }}
    steps:
      - name: Download dummy versioned code
        uses: actions/download-artifact@v8
        with:
          name: dummy-versioned-code
          path: .
      - name: Extract dummy versioned code (Unix)
        if: matrix.os != 'windows'
        run: |
          tar -xzf "dummy-versioned-code.tar.gz" --strip-components=1
          rm -rf "dummy-versioned-code.tar.gz"
      - name: Extract dummy versioned code (Windows)
        if: matrix.os == 'windows'
        shell: pwsh
        run: |
          tar -xzf "dummy-versioned-code.tar.gz" --strip-components=1
          Remove-Item "dummy-versioned-code.tar.gz" -Force
      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.14'
          cache: 'pip'
      - name: Install build tooling
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r python/requirements.txt
      - name: Build wheels
        env:
          CIBW_ARCHS_LINUX: ${{ matrix.cibw_archs_linux }}
          CIBW_ARCHS_WINDOWS: ${{ matrix.cibw_archs_windows }}
          CIBW_ARCHS_MACOS: ${{ matrix.cibw_archs_macos }}
        run: python -m cibuildwheel python --output-dir python/dist
      - name: Test wheel (Windows/macOS)
        if: matrix.os == 'windows' || matrix.os == 'macos'
        shell: bash
        run: |
          set -e
          WHEEL=$(ls python/dist/*.whl | grep -E "cp310" | head -n 1)
          if test -z "${WHEEL}"; then
            echo "No cp310 wheel found, using first available wheel"
            WHEEL=$(ls python/dist/*.whl | head -n 1)
          fi
          echo "Installing wheel: ${WHEEL}"
          python -m pip install "${WHEEL}"

          echo "Running PNG256 encode test..."
          python -c "
          import colopresso
          from colopresso import Config, PngxLossyType, encode_pngx

          print(f'colopresso version: {colopresso.get_version()}')
          print(f'libpng version: {colopresso.get_libpng_version()}')

          with open('assets/example.png', 'rb') as f:
              png_data = f.read()
          print(f'Original PNG size: {len(png_data)} bytes')

          config = Config()
          config.pngx_lossy_enable = True
          config.pngx_lossy_type = PngxLossyType.PALETTE256

          encoded = encode_pngx(png_data, config)
          print(f'Encoded PNG256 size: {len(encoded)} bytes')

          if len(encoded) == 0:
              raise RuntimeError('Encoded data is empty')

          # Verify PNG signature
          if encoded[:8] != b'\\x89PNG\\r\\n\\x1a\\n':
              raise RuntimeError('Invalid PNG signature in output')

          print('PNG256 encode test passed!')
          "
      - name: Test wheel (Linux manylinux)
        if: matrix.os == 'linux'
        run: |
          WHEEL=$(ls python/dist/*.whl | grep -E "manylinux.*cp310" | head -n 1)
          if test -z "${WHEEL}"; then
            echo "No manylinux cp310 wheel found, using first manylinux wheel"
            WHEEL=$(ls python/dist/*.whl | grep "manylinux" | head -n 1)
          fi
          echo "Testing manylinux wheel: ${WHEEL}"
          docker run \
            --rm \
            --volume "${PWD}:/workspace:ro" \
            --workdir "/workspace" \
            python:latest \
            bash -c "
              set -e
              pip install /workspace/${WHEEL}
              python -c \"
          import colopresso
          from colopresso import Config, PngxLossyType, encode_pngx

          print(f'colopresso version: {colopresso.get_version()}')
          print(f'libpng version: {colopresso.get_libpng_version()}')

          with open('assets/example.png', 'rb') as f:
              png_data = f.read()
          print(f'Original PNG size: {len(png_data)} bytes')

          config = Config()
          config.pngx_lossy_enable = True
          config.pngx_lossy_type = PngxLossyType.PALETTE256

          encoded = encode_pngx(png_data, config)
          print(f'Encoded PNG256 size: {len(encoded)} bytes')

          if len(encoded) == 0:
              raise RuntimeError('Encoded data is empty')

          if encoded[:8] != b'\\x89PNG\\r\\n\\x1a\\n':
              raise RuntimeError('Invalid PNG signature in output')

          print('PNG256 encode test passed (manylinux)!')
          \"
            "
      - name: Test wheel (Linux musllinux)
        if: matrix.os == 'linux'
        run: |
          WHEEL=$(ls python/dist/*.whl | grep -E "musllinux.*cp310" | head -n 1)
          if test -z "${WHEEL}"; then
            echo "No musllinux cp310 wheel found, using first musllinux wheel"
            WHEEL=$(ls python/dist/*.whl | grep "musllinux" | head -n 1)
          fi
          echo "Testing musllinux wheel: ${WHEEL}"
          docker run \
            --rm \
            --volume "${PWD}:/workspace:ro" \
            --workdir "/workspace" \
            python:alpine \
            sh -c "
              set -e
              pip install /workspace/${WHEEL}
              python -c \"
          import colopresso
          from colopresso import Config, PngxLossyType, encode_pngx

          print(f'colopresso version: {colopresso.get_version()}')
          print(f'libpng version: {colopresso.get_libpng_version()}')

          with open('assets/example.png', 'rb') as f:
              png_data = f.read()
          print(f'Original PNG size: {len(png_data)} bytes')

          config = Config()
          config.pngx_lossy_enable = True
          config.pngx_lossy_type = PngxLossyType.PALETTE256

          encoded = encode_pngx(png_data, config)
          print(f'Encoded PNG256 size: {len(encoded)} bytes')

          if len(encoded) == 0:
              raise RuntimeError('Encoded data is empty')

          if encoded[:8] != b'\\x89PNG\\r\\n\\x1a\\n':
              raise RuntimeError('Invalid PNG signature in output')

          print('PNG256 encode test passed (musllinux)!')
          \"
            "
