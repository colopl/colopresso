name: Release

on:
  workflow_dispatch:
    inputs:
      major_version:
        description: "Major"
        required: true
        default: "0"
      minor_version:
        description: "Minor"
        required: true
        default: "0"
      patch_version:
        description: "Patch"
        required: true
        default: "0"
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  Prepare:
    runs-on: ubuntu-24.04
    outputs:
      full_version: ${{ steps.generate_version.outputs.full_version }}
      version: ${{ steps.generate_version.outputs.version }}
      version_int: ${{ steps.generate_version.outputs.version_int }}
      update_channel: ${{ steps.generate_version.outputs.update_channel }}
      public_is_prerelease: ${{ steps.generate_version.outputs.public_is_prerelease }}
      internal_channel_raw: ${{ steps.generate_version.outputs.internal_channel_raw }}
      internal_channel_safe: ${{ steps.generate_version.outputs.internal_channel_safe }}
      internal_release_tag: ${{ steps.generate_version.outputs.internal_release_tag }}
      internal_is_prerelease: ${{ steps.generate_version.outputs.internal_is_prerelease }}
      emsdk_version: ${{ steps.get_emsdk_version.outputs.emsdk_version }}
      rust_stable: ${{ steps.get_rust_versions.outputs.rust_stable }}
      rust_nightly: ${{ steps.get_rust_versions.outputs.rust_nightly }}
      wasm_pack_version: ${{ steps.get_rust_versions.outputs.wasm_pack_version }}
    steps:
      - name: Generate version
        id: generate_version
        run: |
          CHANNEL="latest"

          if echo "${{ github.ref_name }}" | grep -qE '^v[0-9]+\.[0-9]+\.[0-9]+$'; then
            VER="$(echo "${{ github.ref_name }}" | cut -c 2-)"
          else
            VER="${{ inputs.major_version }}.${{ inputs.minor_version }}.${{ inputs.patch_version }}"
            CHANNEL="canary"
          fi

          CHANNEL_SAFE="$(printf '%s' "${CHANNEL}" | tr '[:upper:]' '[:lower:]' | tr '_' '-' | tr -cd '0-9a-z-')"
          if test -z "${CHANNEL_SAFE}"; then
            echo "Failed to normalize channel: ${CHANNEL}" >&2
            exit 1
          fi

          if test "${CHANNEL_SAFE}" = "latest"; then
            RELEASE_TAG="v${VER}"
          else
            RELEASE_TAG="v${VER}-${CHANNEL_SAFE}"
          fi

          INTERNAL_RAW="colopl_internal"
          if test "${CHANNEL_SAFE}" != "latest"; then
            INTERNAL_RAW="colopl_internal_canary"
          fi

          INTERNAL_SAFE="$(printf '%s' "${INTERNAL_RAW}" | tr '[:upper:]' '[:lower:]' | tr '_' '-' | tr -cd '0-9a-z-')"
          if test -z "${INTERNAL_SAFE}"; then
            echo "Failed to normalize internal channel: ${INTERNAL_RAW}" >&2
            exit 1
          fi

          INTERNAL_TAG="v${VER}-${INTERNAL_SAFE}"

          PUBLIC_IS_PRERELEASE="false"
          if test "${CHANNEL_SAFE}" != "latest"; then
            PUBLIC_IS_PRERELEASE="true"
          fi

          INTERNAL_IS_PRERELEASE="false"
          if printf '%s' "${INTERNAL_RAW}" | grep -q "_canary"; then
            INTERNAL_IS_PRERELEASE="true"
          fi

          VER_INT=$(echo "${VER}" | awk -F. '{printf "%d\n", sprintf("%03d%03d%03d", $1, $2, $3)}')

          echo "full_version=${RELEASE_TAG}" >> "${GITHUB_OUTPUT}"
          echo "version=${VER}" >> "${GITHUB_OUTPUT}"
          echo "version_int=${VER_INT}" >> "${GITHUB_OUTPUT}"
          echo "update_channel=${CHANNEL_SAFE}" >> "${GITHUB_OUTPUT}"
          echo "public_is_prerelease=${PUBLIC_IS_PRERELEASE}" >> "${GITHUB_OUTPUT}"
          echo "internal_channel_raw=${INTERNAL_RAW}" >> "${GITHUB_OUTPUT}"
          echo "internal_channel_safe=${INTERNAL_SAFE}" >> "${GITHUB_OUTPUT}"
          echo "internal_release_tag=${INTERNAL_TAG}" >> "${GITHUB_OUTPUT}"
          echo "internal_is_prerelease=${INTERNAL_IS_PRERELEASE}" >> "${GITHUB_OUTPUT}"
      - name: Checkout
        uses: actions/checkout@v6
        with:
          submodules: true
          fetch-depth: 1
          ref: ${{ github.ref }}
      - name: Get EMSDK version
        id: get_emsdk_version
        working-directory: "third_party/emsdk"
        run: |
          git fetch --tags
          echo "emsdk_version=$(git describe --tags --abbrev=0)" >> "${GITHUB_OUTPUT}"
      - name: Get Rust versions from rust-toolchain.toml
        id: get_rust_versions
        run: |
          RUST_STABLE=$(grep -E '^channel\s*=' rust-toolchain.toml | sed 's/.*=\s*"\([^"]*\)".*/\1/')
          RUST_NIGHTLY=$(grep -E '^nightly\s*=' rust-toolchain.toml | sed 's/.*=\s*"\([^"]*\)".*/\1/')
          WASM_PACK=$(grep -E '^wasm-pack\s*=' rust-toolchain.toml | sed 's/.*=\s*"\([^"]*\)".*/\1/')
          echo "rust_stable=${RUST_STABLE}" >> "${GITHUB_OUTPUT}"
          echo "rust_nightly=${RUST_NIGHTLY}" >> "${GITHUB_OUTPUT}"
          echo "wasm_pack_version=${WASM_PACK}" >> "${GITHUB_OUTPUT}"
      - name: Versioning
        run: |
          sed -i "s|/\* COLOPL_VERSION_START \*/.*/\* COLOPL_VERSION_END \*/|${{ steps.generate_version.outputs.version_int }}|" "library/include/colopresso.h"
          sed -i "s|VERSION 0.0.0|VERSION ${{ steps.generate_version.outputs.version }}|" "CMakeLists.txt"
          sed -i "s|0.0.0|${{ steps.generate_version.outputs.version }}|" "app/chrome/manifest.json"
          sed -i 's|"version": "0.0.0"|"version": "${{ steps.generate_version.outputs.version }}"|' "package.json"
          sed -i "s|\"channel\": \"[^\"]*\"|\"channel\": \"${{ steps.generate_version.outputs.update_channel }}\"|" "package.json"
          sed -i "s|^version = \".*\"|version = \"${{ steps.generate_version.outputs.version }}\"|" "python/pyproject.toml"
          sed -i "s|^__version__ = \".*\"|__version__ = \"${{ steps.generate_version.outputs.version }}\"|" "python/colopresso/__init__.py"
      - name: Configure package.json for public channel
        run: |
          CHANNEL="${{ steps.generate_version.outputs.update_channel }}"
          BASE_VERSION="${{ steps.generate_version.outputs.version }}"
          PKG="package.json"

          if test ! -f "${PKG}"; then
            echo "package.json not found at ${PKG}" >&2
            exit 1
          fi

          RELEASE_TYPE="release"
          VERSION_VALUE="${BASE_VERSION}"

          if test "${CHANNEL}" != "latest"; then
            RELEASE_TYPE="prerelease"
            VERSION_VALUE="${BASE_VERSION}-${CHANNEL}"
          fi

          TMP="$(mktemp)"
          jq --arg channel "${CHANNEL}" --arg version "${VERSION_VALUE}" --arg releaseType "${RELEASE_TYPE}" '
            .build.publish as $p
            | if ($p | type) != "array" or ($p | length) == 0 then error("package.json is missing build.publish") else . end
            | .build as $b
            | if $b == null then error("package.json is missing build configuration") else . end
            | if $b.productName == null then error("package.json is missing build.productName") else . end
            | .version = $version
            | .build.publish[0].channel = $channel
            | .build.publish[0].releaseType = $releaseType
            | if $channel != "latest" then .build.productName = ($b.productName + "_" + $channel) else . end
          ' "${PKG}" > "${TMP}"
          mv "${TMP}" "${PKG}"
      - name: Tar versioned code
        run: |
          tar -czf "../versioned-code.tar.gz" -C .. "$(basename "$PWD")"
          mv "../versioned-code.tar.gz" "./versioned-code.tar.gz"
      - name: Upload versioned code
        uses: actions/upload-artifact@v6
        with:
          name: versioned-code
          path: ./versioned-code.tar.gz
          retention-days: 1
  Source:
    if: false
    needs: Prepare
    runs-on: ubuntu-24.04
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v7
        with:
          name: versioned-code
          path: .
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          rm -rf "versioned-code.tar.gz"
      - name: Create versioned source code
        run: |
          cp -a . "/tmp/colopresso"
          cd "/tmp/colopresso"
            rm -rf "build"
            rm -rf "third_party"
          cd -
          mkdir -p "${{ github.workspace }}/dist"
          tar -czf "${{ github.workspace }}/dist/colopresso_source.tar.gz" -C "/tmp" "colopresso"
      - name: Upload artifacts
        uses: actions/upload-artifact@v6
        with:
          name: colopresso-source
          path: dist/
  WindowsElectron:
    if: false
    needs: Prepare
    strategy:
      matrix:
        channel:
          - ${{ needs.Prepare.outputs.update_channel }}
          - ${{ needs.Prepare.outputs.internal_channel_raw }}
    runs-on: windows-latest
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v7
        with:
          name: versioned-code
          path: .
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          Remove-Item "versioned-code.tar.gz" -Force
      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0
        with:
          version: 10
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '24'
          cache: 'pnpm'
      - name: Override productName for internal channel
        if: ${{ startsWith(matrix.channel, 'colopl_internal') }}
        shell: pwsh
        run: |
          $pkgPath = "package.json"
          if (-not (Test-Path $pkgPath)) { Write-Error "package.json not found at $pkgPath"; exit 1 }

          $json = Get-Content $pkgPath -Raw | ConvertFrom-Json
          if (-not $json.build) { Write-Error "package.json is missing build configuration"; exit 1 }

          $rawChannel = "${{ matrix.channel }}"
          $safeChannel = $rawChannel.ToLower().Replace('_','-') -replace '[^0-9a-z-]', ''
          if (-not $safeChannel) { Write-Error "Failed to normalize channel: $rawChannel"; exit 1 }

          $baseVersion = "${{ needs.Prepare.outputs.version }}"
          $releaseType = if ($rawChannel -match 'canary') { 'prerelease' } else { 'release' }
          $json.version = "${baseVersion}-$safeChannel"
          $json.build.productName = "colopresso_${{ matrix.channel }}"
          $json.build.publish[0].channel = $safeChannel
          $json.build.publish[0].releaseType = $releaseType
          $json | ConvertTo-Json -Depth 64 | Set-Content $pkgPath -Encoding UTF8
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@f7ccc83f9ed1e5b9c81d8a67d7ad1a747e22a561
        with:
          toolchain: ${{ needs.Prepare.outputs.rust_nightly }}
          targets: wasm32-unknown-emscripten,wasm32-unknown-unknown
          components: rust-src
      - name: Setup wasm-pack
        run: cargo install "wasm-pack" --version "${{ needs.Prepare.outputs.wasm_pack_version }}" --locked
      - name: Setup emsdk
        shell: pwsh
        working-directory: "third_party/emsdk"
        run: |
          ./emsdk.ps1 install "${{ needs.Prepare.outputs.emsdk_version }}"
          ./emsdk.ps1 activate "${{ needs.Prepare.outputs.emsdk_version }}"
          . "./emsdk_env.ps1"
          Get-ChildItem env: | Where-Object { $_.Name -match '^(EMSDK|EM_|BINARYEN)' } | ForEach-Object {
            "$($_.Name)=$($_.Value)" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          }
          "$env:EMSDK" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          "$env:EMSDK\upstream\emscripten" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          "$env:EMSDK\node\$(Get-ChildItem "$env:EMSDK\node" | Select-Object -First 1 -ExpandProperty Name)_64bit\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
      - name: Build Electron app
        shell: pwsh
        run: |
          if ("${{ matrix.channel }}" -eq "colopl_internal" -or "${{ matrix.channel }}" -eq "colopl_internal_canary") {
              $env:WIN_CSC_LINK = "${{ secrets.WINDOWS_CERTIFICATE_BASE64 }}"
              $env:WIN_CSC_KEY_PASSWORD = "${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}"
          }

          emcmake cmake -B "build" -DCOLOPRESSO_ELECTRON_APP=ON -DCOLOPRESSO_ELECTRON_TARGETS="--win"
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
          cmake --build "build" --config "Release" --parallel
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Copy artifacts
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path "dist" | Out-Null
          Get-ChildItem -Path "dist_build" -Include "*.exe","*.yml","*.blockmap" -Recurse -File | ForEach-Object {
            Copy-Item $_.FullName -Destination "dist\"
          }
      - name: Upload artifacts
        uses: actions/upload-artifact@v6
        with:
          name: colopresso-electron-windows-${{ matrix.channel }}
          path: dist/
          if-no-files-found: error
  macOSElectron:
    if: false
    needs: Prepare
    runs-on: macos-latest
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v7
        with:
          name: versioned-code
          path: .
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          rm -rf "versioned-code.tar.gz"
      - name: Install LLVM (for wasm32 targets)
        run: brew install "llvm"
      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0
        with:
          version: 10
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '24'
          cache: 'pnpm'
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@f7ccc83f9ed1e5b9c81d8a67d7ad1a747e22a561
        with:
          toolchain: ${{ needs.Prepare.outputs.rust_nightly }}
          targets: wasm32-unknown-emscripten,wasm32-unknown-unknown
          components: rust-src
      - name: Setup wasm-pack
        run: cargo install "wasm-pack" --version "${{ needs.Prepare.outputs.wasm_pack_version }}" --locked
      - name: Setup emsdk
        working-directory: "third_party/emsdk"
        run: |
          ./emsdk install "${{ needs.Prepare.outputs.emsdk_version }}"
          ./emsdk activate "${{ needs.Prepare.outputs.emsdk_version }}"
          . "./emsdk_env.sh"
          env | grep -E '^(EMSDK|EM_|BINARYEN)' | while IFS='=' read -r KEY VALUE; do
            echo "${KEY}=${VALUE}" >> "${GITHUB_ENV}"
          done
          echo "${EMSDK}" >> "${GITHUB_PATH}"
          echo "${EMSDK}/upstream/emscripten" >> "${GITHUB_PATH}"
          echo "${EMSDK}/node/$(ls "${EMSDK}/node" | head -n 1)_64bit/bin" >> "${GITHUB_PATH}"
      - name: Detect macOS signing configuration
        id: macos_signing
        shell: bash
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
        run: |
          HAS_CERT=false
          HAS_NOTARY=false

          if test -n "${MACOS_CERTIFICATE}" && test -n "${MACOS_CERTIFICATE_PWD}"; then
            HAS_CERT=true
          fi

          if test -n "${APPLE_API_KEY}" && test -n "${APPLE_API_KEY_ID}" && test -n "${APPLE_API_ISSUER}"; then
            HAS_NOTARY=true
          fi

          echo "HAS_CERT=${HAS_CERT}" >> "${GITHUB_OUTPUT}"
          echo "HAS_NOTARY=${HAS_NOTARY}" >> "${GITHUB_OUTPUT}"

          if test "${HAS_CERT}" != "true"; then
            echo "CSC_IDENTITY_AUTO_DISCOVERY=false" >> "${GITHUB_ENV}"
          fi
      - name: Prepare Apple API Key for notarization
        id: prepare_apple_key
        if: ${{ steps.macos_signing.outputs.HAS_NOTARY == 'true' }}
        env:
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
        run: |
          mkdir -p "${RUNNER_TEMP}/private_keys"
          KEY_PATH="${RUNNER_TEMP}/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8"
          printf '%s' "${APPLE_API_KEY}" > "${KEY_PATH}"
          chmod 600 "${KEY_PATH}"
          echo "KEY_PATH=${KEY_PATH}" >> "${GITHUB_OUTPUT}"
      - name: Build Electron app (signed & notarized)
        run: |
          if test "${HAS_CERT}" = "true"; then
            export CSC_LINK="${MACOS_CERTIFICATE}"
            export CSC_KEY_PASSWORD="${MACOS_CERTIFICATE_PWD}"
          else
            unset CSC_LINK
            unset CSC_KEY_PASSWORD
            export CSC_IDENTITY_AUTO_DISCOVERY=false
          fi

          if test "${HAS_NOTARY}" = "true"; then
            export APPLE_API_KEY="${NOTARY_KEY_PATH}"
            export APPLE_API_KEY_ID="${APPLE_API_KEY_ID}"
            export APPLE_API_ISSUER="${APPLE_API_ISSUER}"
          else
            unset APPLE_API_KEY
            unset APPLE_API_KEY_ID
            unset APPLE_API_ISSUER
          fi

          emcmake cmake -B "build" -DCOLOPRESSO_ELECTRON_APP=ON -DCOLOPRESSO_ELECTRON_TARGETS="--mac"
          cmake --build "build" --config "Release" --parallel
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HAS_CERT: ${{ steps.macos_signing.outputs.HAS_CERT }}
          HAS_NOTARY: ${{ steps.macos_signing.outputs.HAS_NOTARY }}
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          NOTARY_KEY_PATH: ${{ steps.prepare_apple_key.outputs.KEY_PATH }}
      - name: Clean up Apple API Key
        if: ${{ always() && steps.macos_signing.outputs.HAS_NOTARY == 'true' }}
        env:
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
        run: rm -f "${RUNNER_TEMP}/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8"
      - name: Copy artifacts
        run: |
          mkdir -p "dist"
          find "dist_build" -type f \( -name '*.dmg' -o -name '*.dmg.blockmap' -o -name '*.zip' -o -name '*.zip.blockmap' -o -name '*.yml' \) \
            -exec cp {} "dist/" \;
      - name: Upload artifacts
        uses: actions/upload-artifact@v6
        with:
          name: colopresso-electron-macos
          path: dist/
          if-no-files-found: error
  ChromeExtension:
    if: false
    needs: Prepare
    runs-on: ubuntu-24.04
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v7
        with:
          name: versioned-code
          path: .
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          rm -rf "versioned-code.tar.gz"
      - name: Setup builder
        run: |
          docker build \
            --file "Dockerfile" \
            --tag "chrome" \
            --build-arg ENABLE_VALGRIND=0 \
            --build-arg ENABLE_CLANG=1 \
            --build-arg ENABLE_EMSDK=1 \
            --build-arg EMSDK_VERSION="${{ needs.Prepare.outputs.emsdk_version }}" \
            --target "builder" \
            .
      - name: Build Chrome Extension
        run: |
          docker run \
            --rm \
            --volume "${PWD}:/workspace" \
            --workdir "/workspace" \
            chrome \
            /bin/bash -lc '
              set -e
              rm -rf "build"
              emcmake cmake -B "build" \
                -DCMAKE_BUILD_TYPE="Release" \
                -DCOLOPRESSO_CHROME_EXTENSION=ON
              cmake --build "build" --config "Release" --parallel="$(($(nproc)-1))"
            '
          mkdir -p "dist"
          tar -czf "dist/colopresso_chrome.tar.gz" -C "${PWD}/build" "chrome"
      - name: Upload artifacts
        uses: actions/upload-artifact@v6
        with:
          name: colopresso-chrome-extension
          path: dist/
  WindowsCLI:
    if: false
    needs: Prepare
    strategy:
      matrix:
        runs-on:
          - windows-latest
          - windows-11-arm
        channel:
          - ${{ needs.Prepare.outputs.update_channel }}
          - ${{ needs.Prepare.outputs.internal_channel_raw }}
    runs-on: ${{ matrix.runs-on }}
    env:
      COLOPRESSO_CLI_EXE: 'build\cli\Release\colopresso.exe'
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v7
        with:
          name: versioned-code
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          Remove-Item "versioned-code.tar.gz" -Force
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@f7ccc83f9ed1e5b9c81d8a67d7ad1a747e22a561
        with:
          toolchain: ${{ needs.Prepare.outputs.rust_stable }}
      - name: Configure CMake
        run: cmake -B build -DCMAKE_BUILD_TYPE="Release" -DCOLOPRESSO_USE_CLI=ON
      - name: Build
        run: cmake --build "build" --config "Release" --target "colopresso_cli" --parallel
      - name: Test
        run: ctest --test-dir "build" --build-config "Release" --output-on-failure
      - name: Check CLI
        shell: pwsh
        run: |
          & "${env:COLOPRESSO_CLI_EXE}" --version
      - name: Sign binary
        shell: pwsh
        if: startsWith(matrix.channel, 'colopl_internal')
        env:
          WIN_CSC_LINK: ${{ secrets.WINDOWS_CERTIFICATE_BASE64 }}
          WIN_CSC_KEY_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: |
          $exePath = "${env:COLOPRESSO_CLI_EXE}"

          if ($env:WIN_CSC_LINK) {
            Write-Host "Certificate found, creating signed internal binary..."
            $certBytes = [Convert]::FromBase64String($env:WIN_CSC_LINK)
            $certPath = "$env:RUNNER_TEMP\certificate.pfx"
            [IO.File]::WriteAllBytes($certPath, $certBytes)

            $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\" -Recurse -Filter "signtool.exe" | Where-Object { $_.FullName -match "x64" } | Select-Object -First 1 -ExpandProperty FullName
            & $signtool sign /f "$certPath" /p "$env:WIN_CSC_KEY_PASSWORD" /fd sha256 "$exePath"

            Remove-Item "$certPath" -Force
            Write-Host "Signed internal binary generated"
          } else {
            Write-Host "No certificate found, skipping signing"
          }
      - name: Prepare artifact
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path "dist" | Out-Null
          Copy-Item "${env:COLOPRESSO_CLI_EXE}" "dist/colopresso_windows_cli_${{ matrix.runs-on == 'windows-11-arm' && 'arm64' || 'x64' }}${{ matrix.channel != 'latest' && format('_{0}', matrix.channel) || '' }}.exe"
      - name: Upload artifact
        uses: actions/upload-artifact@v6
        with:
          name: colopresso-cli-windows-${{ matrix.runs-on == 'windows-11-arm' && 'arm64' || 'x64' }}-${{ matrix.channel }}
          path: dist/
          if-no-files-found: error
  macOSCLI:
    if: false
    needs: Prepare
    strategy:
      matrix:
        arch:
          - name: apple_silicon
            rust_target: aarch64-apple-darwin
            runs-on: macos-15
          - name: intel
            rust_target: x86_64-apple-darwin
            runs-on: macos-15-intel
    runs-on: ${{ matrix.arch.runs-on }}
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v7
        with:
          name: versioned-code
          path: .
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          rm -rf "versioned-code.tar.gz"
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@f7ccc83f9ed1e5b9c81d8a67d7ad1a747e22a561
        with:
          toolchain: ${{ needs.Prepare.outputs.rust_stable }}
          targets: ${{ matrix.arch.rust_target }}
      - name: Detect macOS CLI signing configuration
        id: macos_cli_signing
        shell: bash
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
        run: |
          HAS_CERT=false
          HAS_NOTARY=false

          if test -n "${MACOS_CERTIFICATE}" && test -n "${MACOS_CERTIFICATE_PWD}"; then
            HAS_CERT=true
          fi

          if test -n "${APPLE_API_KEY}" && test -n "${APPLE_API_KEY_ID}" && test -n "${APPLE_API_ISSUER}"; then
            HAS_NOTARY=true
          fi

          echo "HAS_CERT=${HAS_CERT}" >> "${GITHUB_OUTPUT}"
          echo "HAS_NOTARY=${HAS_NOTARY}" >> "${GITHUB_OUTPUT}"
      - name: Configure CMake
        run: |
          cmake -B build \
            -DCMAKE_BUILD_TYPE="Release" \
            -DCOLOPRESSO_USE_CLI=ON \
            -DCOLOPRESSO_USE_TESTS=ON \
            ${{ matrix.arch.name == 'intel' && '-DAOM_TARGET_CPU=generic' || '' }}
      - name: Build
        run: cmake --build "build" --config "Release" --parallel
      - name: Check CLI
        run: ./build/cli/colopresso --version
      - name: Sign and notarize binary
        env:
          HAS_CERT: ${{ steps.macos_cli_signing.outputs.HAS_CERT }}
          HAS_NOTARY: ${{ steps.macos_cli_signing.outputs.HAS_NOTARY }}
          CSC_LINK: ${{ steps.macos_cli_signing.outputs.HAS_CERT == 'true' && secrets.MACOS_CERTIFICATE || '' }}
          CSC_KEY_PASSWORD: ${{ steps.macos_cli_signing.outputs.HAS_CERT == 'true' && secrets.MACOS_CERTIFICATE_PWD || '' }}
          APPLE_API_KEY: ${{ steps.macos_cli_signing.outputs.HAS_NOTARY == 'true' && secrets.APPLE_API_KEY || '' }}
          APPLE_API_KEY_ID: ${{ steps.macos_cli_signing.outputs.HAS_NOTARY == 'true' && secrets.APPLE_API_KEY_ID || '' }}
          APPLE_API_ISSUER: ${{ steps.macos_cli_signing.outputs.HAS_NOTARY == 'true' && secrets.APPLE_API_ISSUER || '' }}
        run: |
          if test "${HAS_CERT}" = "true"; then
            echo "Certificate found, signing binary..."
            echo "${CSC_LINK}" | base64 --decode > certificate.p12
            security create-keychain -p actions build.keychain
            security default-keychain -s build.keychain
            security unlock-keychain -p actions build.keychain
            security import certificate.p12 -k build.keychain -P "${CSC_KEY_PASSWORD}" -T "/usr/bin/codesign"
            security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k actions build.keychain
            rm certificate.p12

            codesign --force --options runtime --sign "Developer ID Application" --timestamp "build/cli/colopresso"
            codesign --verify --verbose "build/cli/colopresso"
            echo "Binary signed successfully"
          else
            echo "No certificate found, skipping signing"
          fi

          if test "${HAS_NOTARY}" = "true"; then
            echo "API key found, notarizing binary..."
            mkdir -p "${RUNNER_TEMP}/private_keys"
            echo "${APPLE_API_KEY}" > "${RUNNER_TEMP}/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8"
            chmod 600 "${RUNNER_TEMP}/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8"

            ditto -c -k --keepParent "build/cli/colopresso" "colopresso.zip"
            xcrun notarytool submit "colopresso.zip" \
              --key "${RUNNER_TEMP}/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8" \
              --key-id "${APPLE_API_KEY_ID}" \
              --issuer "${APPLE_API_ISSUER}" \
              --wait

            rm "colopresso.zip"
            echo "Binary notarized successfully"
          else
            echo "No API key found, skipping notarization"
          fi
      - name: Clean up
        if: always()
        env:
          HAS_NOTARY: ${{ steps.macos_cli_signing.outputs.HAS_NOTARY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
        run: |
          if test "${HAS_NOTARY}" = "true"; then
            rm -f "${RUNNER_TEMP}/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8"
          fi
          security delete-keychain build.keychain 2>/dev/null || true
      - name: Prepare artifact
        run: |
          mkdir -p "artifact"
          cp "build/cli/colopresso" "artifact/colopresso-cli-macos-${{ matrix.arch.name }}"
      - name: Upload artifact
        uses: actions/upload-artifact@v6
        with:
          name: colopresso-cli-macos-${{ matrix.arch.name }}
          path: artifact/
          if-no-files-found: error
  LinuxCLI:
    if: false
    needs: Prepare
    strategy:
      matrix:
        include:
          - arch: amd64
            runs-on: ubuntu-24.04
          - arch: arm64
            runs-on: ubuntu-24.04-arm
    runs-on: ${{ matrix.runs-on }}
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v7
        with:
          name: versioned-code
          path: .
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          rm -rf "versioned-code.tar.gz"
      - name: Build container
        run: |
          docker build \
            --file "Dockerfile.alpine" \
            --tag "cli-${{ matrix.arch }}" \
            .
      - name: Build CLI in container
        run: |
          docker run \
            --rm \
            --volume "${PWD}:/workspace" \
            --workdir "/workspace" \
            cli-${{ matrix.arch }} \
            sh -c '
              set -e
              cmake -B build \
                -DCMAKE_BUILD_TYPE=Release \
                -DCMAKE_EXE_LINKER_FLAGS="-static" \
                -DCOLOPRESSO_USE_CLI=ON
              cmake --build build --config Release --target "colopresso_cli" --parallel=$(($(nproc)-1))
              strip build/cli/colopresso
              build/cli/colopresso --version
            '
      - name: Test binary in minimal container
        run: |
          docker run \
            --rm \
            --volume "${PWD}/build/cli/colopresso:/colopresso:ro" \
            busybox:musl \
            /colopresso --version
      - name: Prepare artifact
        run: |
          mkdir -p "artifact"
          cp "build/cli/colopresso" "artifact/colopresso-cli-linux-${{ matrix.arch }}"
      - name: Upload artifact
        uses: actions/upload-artifact@v6
        with:
          name: colopresso-cli-linux-${{ matrix.arch }}
          path: artifact/
          if-no-files-found: error
  PythonWheel:
    needs: Prepare
    strategy:
      matrix:
        include:
          - os: linux
            arch: amd64
            runs-on: ubuntu-24.04
            cibw_archs_linux: x86_64
          - os: linux
            arch: arm64
            runs-on: ubuntu-24.04-arm
            cibw_archs_linux: aarch64
          - os: windows
            arch: amd64
            runs-on: windows-latest
            cibw_archs_windows: AMD64
          - os: windows
            arch: arm64
            runs-on: windows-11-arm
            cibw_archs_windows: ARM64
          - os: macos
            arch: amd64
            runs-on: macos-15-intel
            cibw_archs_macos: x86_64
          - os: macos
            arch: arm64
            runs-on: macos-15
            cibw_archs_macos: arm64
    runs-on: ${{ matrix.runs-on }}
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v7
        with:
          name: versioned-code
          path: .
      - name: Extract versioned code (Unix)
        if: matrix.os != 'windows'
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          rm -rf "versioned-code.tar.gz"
      - name: Extract versioned code (Windows)
        if: matrix.os == 'windows'
        shell: pwsh
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          Remove-Item "versioned-code.tar.gz" -Force
      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.11'
          cache: 'pip'
      - name: Install build tooling
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r python/requirements.txt
      - name: Build wheels
        env:
          CIBW_ARCHS_LINUX: ${{ matrix.cibw_archs_linux }}
          CIBW_ARCHS_WINDOWS: ${{ matrix.cibw_archs_windows }}
          CIBW_ARCHS_MACOS: ${{ matrix.cibw_archs_macos }}
        run: python -m cibuildwheel python --output-dir python/dist
      - name: Test wheel (Windows/macOS)
        if: matrix.os == 'windows' || matrix.os == 'macos'
        shell: bash
        run: |
          set -e
          WHEEL=$(ls python/dist/*.whl | grep -E "cp310" | head -n 1)
          if test -z "${WHEEL}"; then
            echo "No cp310 wheel found, using first available wheel"
            WHEEL=$(ls python/dist/*.whl | head -n 1)
          fi
          echo "Installing wheel: ${WHEEL}"
          python -m pip install "${WHEEL}"

          echo "Running PNG256 encode test..."
          python -c "
          import colopresso
          from colopresso import Config, PngxLossyType, encode_pngx

          print(f'colopresso version: {colopresso.get_version()}')
          print(f'libpng version: {colopresso.get_libpng_version()}')

          with open('assets/example.png', 'rb') as f:
              png_data = f.read()
          print(f'Original PNG size: {len(png_data)} bytes')

          config = Config()
          config.pngx_lossy_enable = True
          config.pngx_lossy_type = PngxLossyType.PALETTE256

          encoded = encode_pngx(png_data, config)
          print(f'Encoded PNG256 size: {len(encoded)} bytes')

          if len(encoded) == 0:
              raise RuntimeError('Encoded data is empty')

          # Verify PNG signature
          if encoded[:8] != b'\\x89PNG\\r\\n\\x1a\\n':
              raise RuntimeError('Invalid PNG signature in output')

          print('PNG256 encode test passed!')
          "
      - name: Test wheel (Linux manylinux)
        if: matrix.os == 'linux'
        run: |
          WHEEL=$(ls python/dist/*.whl | grep -E "manylinux.*cp310" | head -n 1)
          if test -z "${WHEEL}"; then
            echo "No manylinux cp310 wheel found, using first manylinux wheel"
            WHEEL=$(ls python/dist/*.whl | grep "manylinux" | head -n 1)
          fi
          echo "Testing manylinux wheel: ${WHEEL}"
          MANYLINUX_IMAGE="quay.io/pypa/manylinux_2_28_${{ matrix.arch == 'amd64' && 'x86_64' || 'aarch64' }}"
          docker run \
            --rm \
            --volume "${PWD}:/workspace:ro" \
            --workdir "/workspace" \
            "${MANYLINUX_IMAGE}" \
            bash -c "
              set -e
              /opt/python/cp310-cp310/bin/pip install /workspace/${WHEEL}
              /opt/python/cp310-cp310/bin/python -c \"
          import colopresso
          from colopresso import Config, PngxLossyType, encode_pngx

          print(f'colopresso version: {colopresso.get_version()}')
          print(f'libpng version: {colopresso.get_libpng_version()}')

          with open('assets/example.png', 'rb') as f:
              png_data = f.read()
          print(f'Original PNG size: {len(png_data)} bytes')

          config = Config()
          config.pngx_lossy_enable = True
          config.pngx_lossy_type = PngxLossyType.PALETTE256

          encoded = encode_pngx(png_data, config)
          print(f'Encoded PNG256 size: {len(encoded)} bytes')

          if len(encoded) == 0:
              raise RuntimeError('Encoded data is empty')

          if encoded[:8] != b'\\x89PNG\\r\\n\\x1a\\n':
              raise RuntimeError('Invalid PNG signature in output')

          print('PNG256 encode test passed (manylinux)!')
          \"
            "
      - name: Test wheel (Linux musllinux)
        if: matrix.os == 'linux'
        run: |
          WHEEL=$(ls python/dist/*.whl | grep -E "musllinux.*cp310" | head -n 1)
          if test -z "${WHEEL}"; then
            echo "No musllinux cp310 wheel found, using first musllinux wheel"
            WHEEL=$(ls python/dist/*.whl | grep "musllinux" | head -n 1)
          fi
          echo "Testing musllinux wheel: ${WHEEL}"
          MUSLLINUX_IMAGE="quay.io/pypa/musllinux_1_2_${{ matrix.arch == 'amd64' && 'x86_64' || 'aarch64' }}"
          docker run \
            --rm \
            --volume "${PWD}:/workspace:ro" \
            --workdir "/workspace" \
            "${MUSLLINUX_IMAGE}" \
            sh -c "
              set -e
              /opt/python/cp310-cp310/bin/pip install /workspace/${WHEEL}
              /opt/python/cp310-cp310/bin/python -c \"
          import colopresso
          from colopresso import Config, PngxLossyType, encode_pngx

          print(f'colopresso version: {colopresso.get_version()}')
          print(f'libpng version: {colopresso.get_libpng_version()}')

          with open('assets/example.png', 'rb') as f:
              png_data = f.read()
          print(f'Original PNG size: {len(png_data)} bytes')

          config = Config()
          config.pngx_lossy_enable = True
          config.pngx_lossy_type = PngxLossyType.PALETTE256

          encoded = encode_pngx(png_data, config)
          print(f'Encoded PNG256 size: {len(encoded)} bytes')

          if len(encoded) == 0:
              raise RuntimeError('Encoded data is empty')

          if encoded[:8] != b'\\x89PNG\\r\\n\\x1a\\n':
              raise RuntimeError('Invalid PNG signature in output')

          print('PNG256 encode test passed (musllinux)!')
          \"
            "
      - name: Upload artifacts
        uses: actions/upload-artifact@v6
        with:
          name: colopresso-python-wheel-${{ matrix.os }}-${{ matrix.arch }}
          path: python/dist/*.whl
          if-no-files-found: error
  PublishPyPI:
    needs:
      - Prepare
      - PythonWheel
    environment: pypi
    runs-on: ubuntu-24.04
    permissions:
      id-token: write
    steps:
      - name: Download wheel artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: colopresso-python-wheel-*
          merge-multiple: true
          path: dist/
      - name: Test
        run: |
          ls -alh dist/
      # - name: Publish to PyPI
      #   uses: pypa/gh-action-pypi-publish@ed0c53931b1dc9bd32cbe73a98c7f6766f8a527e # v1.13.0
      #   with:
      #     packages-dir: dist/
  Release:
    if: false
    needs:
      - Prepare
      - WindowsElectron
      - macOSElectron
      - ChromeExtension
      - Source
      - WindowsCLI
      - macOSCLI
      - LinuxCLI
      - PythonWheel
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          submodules: false
          fetch-depth: 1
          ref: ${{ github.ref }}
      - name: Download Chrome Extension Artifacts
        uses: actions/download-artifact@v7
        with:
          name: colopresso-chrome-extension
          path: artifacts/
      - name: Download Source Artifacts
        uses: actions/download-artifact@v7
        with:
          name: colopresso-source
          path: artifacts/
      - name: Download Electron Artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: colopresso-electron-*
          merge-multiple: true
          path: artifacts/
      - name: Download CLI Artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: colopresso-cli-*
          merge-multiple: true
          path: artifacts/
      - name: Download Python Wheel Artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: colopresso-python-wheel-*
          merge-multiple: true
          path: artifacts/
      - name: Create Release (internal)
        if: ${{ needs.Prepare.outputs.internal_is_prerelease == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          INTERNAL_TAG="${{ needs.Prepare.outputs.internal_release_tag }}"
          INTERNAL_RAW="${{ needs.Prepare.outputs.internal_channel_raw }}"
          INTERNAL_IS_PRERELEASE="${{ needs.Prepare.outputs.internal_is_prerelease }}"

          if gh release view "${INTERNAL_TAG}" > /dev/null 2>&1; then
            echo "Internal release already exists: ${INTERNAL_TAG}"
            exit 0
          fi

          gh release create "${INTERNAL_TAG}" \
            --title "${{ needs.Prepare.outputs.version }} (${INTERNAL_RAW})" \
            --generate-notes \
            --prerelease="${INTERNAL_IS_PRERELEASE}" \
            --draft=false
          for RETRY in {1..10}; do
            if gh release view "${INTERNAL_TAG}" > /dev/null 2>&1; then
              break
            fi
            echo "Waiting for internal release to be available... (${RETRY}/10)"
            sleep 2
          done
      - name: Create Release (public)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PUBLIC_TAG="${{ needs.Prepare.outputs.full_version }}"
          PUBLIC_IS_PRERELEASE="${{ needs.Prepare.outputs.public_is_prerelease }}"

          if gh release view "${PUBLIC_TAG}" > /dev/null 2>&1; then
            echo "Public release already exists: ${PUBLIC_TAG}"
            exit 0
          fi

          gh release create "${PUBLIC_TAG}" \
            --title "${{ needs.Prepare.outputs.version }}" \
            --generate-notes \
            --prerelease="${PUBLIC_IS_PRERELEASE}" \
            --draft=false
          for RETRY in $(seq 1 10); do
            if gh release view "${PUBLIC_TAG}" > /dev/null 2>&1; then
              break
            fi
            echo "Waiting for public release to be available... (${RETRY}/10)"
            sleep 2
          done
      - name: Split assets
        run: |
          INTERNAL_RAW="${{ needs.Prepare.outputs.internal_channel_raw }}"
          INTERNAL_SAFE="${{ needs.Prepare.outputs.internal_channel_safe }}"

          mkdir -p "public_assets" "internal_assets"

          for FILE in "${{ github.workspace }}/artifacts"/*; do
            if test -f "${FILE}"; then
              BASENAME="$(basename "${FILE}")"
              if printf '%s' "${BASENAME}" | grep -q "${INTERNAL_RAW}"; then
                mv "${FILE}" "internal_assets/"
              elif printf '%s' "${BASENAME}" | grep -q "${INTERNAL_SAFE}"; then
                mv "${FILE}" "internal_assets/"
              else
                mv "${FILE}" "public_assets/"
              fi
            fi
          done

          if test "${{ needs.Prepare.outputs.update_channel }}" = "latest" && test "${INTERNAL_RAW}" = "colopl_internal"; then
            for FILE in "${{ github.workspace }}/internal_assets"/*; do
              if test -f "${FILE}"; then
                cp "${FILE}" "public_assets/"
              fi
            done
          fi
      - name: Generate and upload checksums (public)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PUBLIC_TAG="${{ needs.Prepare.outputs.full_version }}"

          cd "public_assets" || exit 1
          find . -type f -exec sh -c 'echo "$(sha256sum "$1" | cut -d" " -f1)  $(basename "$1")"' _ {} \; > "checksums.txt"
          gh release upload "${PUBLIC_TAG}" "checksums.txt" --clobber
          cd -
      - name: Upload Release Assets (public)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PUBLIC_TAG="${{ needs.Prepare.outputs.full_version }}"

          rm -rf "${{ github.workspace }}/public_assets/app-update.yml"
          rm -rf "${{ github.workspace }}/public_assets/builder-debug.yml"
          rm -rf "${{ github.workspace }}/public_assets/builder-effective-config.yaml"
          rm -rf "${{ github.workspace }}/public_assets/elevate.exe"
          for FILE in "${{ github.workspace }}/public_assets"/*; do
            if test -f "${FILE}"; then
              gh release upload "${PUBLIC_TAG}" "${FILE}" --clobber
            fi
          done
      - name: Generate and upload checksums (internal)
        if: ${{ needs.Prepare.outputs.internal_is_prerelease == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          INTERNAL_TAG="${{ needs.Prepare.outputs.internal_release_tag }}"

          if test ! -d "internal_assets" || test -z "$(ls -A "internal_assets" 2>/dev/null)"; then
            echo "No internal assets found; skipping internal checksums."
            exit 0
          fi

          cd "internal_assets" || exit 1
          find . -type f -exec sh -c 'echo "$(sha256sum "$1" | cut -d" " -f1)  $(basename "$1")"' _ {} \; > "checksums.txt"
          gh release upload "${INTERNAL_TAG}" "checksums.txt" --clobber
          cd -
      - name: Upload Release Assets (internal)
        if: ${{ needs.Prepare.outputs.internal_is_prerelease == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          INTERNAL_TAG="${{ needs.Prepare.outputs.internal_release_tag }}"

          if test ! -d "internal_assets" || test -z "$(ls -A "internal_assets" 2>/dev/null)"; then
            echo "No internal assets found; skipping internal upload."
            exit 0
          fi

          rm -rf "${{ github.workspace }}/internal_assets/app-update.yml"
          rm -rf "${{ github.workspace }}/internal_assets/builder-debug.yml"
          rm -rf "${{ github.workspace }}/internal_assets/builder-effective-config.yaml"
          rm -rf "${{ github.workspace }}/internal_assets/elevate.exe"
          for FILE in "${{ github.workspace }}/internal_assets"/*; do
            if test -f "${FILE}"; then
              gh release upload "${INTERNAL_TAG}" "${FILE}" --clobber
            fi
          done
