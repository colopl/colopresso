name: Release

on:
  workflow_dispatch:
    inputs:
      major_version:
        description: "Major"
        required: true
        default: "0"
      minor_version:
        description: "Minor"
        required: true
        default: "0"
      patch_version:
        description: "Patch"
        required: true
        default: "0"
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  Prepare:
    runs-on: ubuntu-24.04
    outputs:
      full_version: ${{ steps.generate_version.outputs.full_version }}
      version: ${{ steps.generate_version.outputs.version }}
      version_int: ${{ steps.generate_version.outputs.version_int }}
      update_channel: ${{ steps.generate_version.outputs.update_channel }}
      emsdk_version: ${{ steps.get_emsdk_version.outputs.emsdk_version }}
    steps:
      - name: Generate version
        id: generate_version
        run: |
          CHANNEL="latest"

          if echo "${{ github.ref_name }}" | grep -qE '^v[0-9]+\.[0-9]+\.[0-9]+$'; then
            VER="$(echo "${{ github.ref_name }}" | cut -c 2-)"
          else
            VER="${{ inputs.major_version }}.${{ inputs.minor_version }}.${{ inputs.patch_version }}"
            CHANNEL="canary"
          fi

          CHANNEL_SAFE="$(printf '%s' "${CHANNEL}" | tr '[:upper:]' '[:lower:]' | tr '_' '-' | tr -cd '0-9a-z-')"
          if test -z "${CHANNEL_SAFE}"; then
            echo "Failed to normalize channel: ${CHANNEL}" >&2
            exit 1
          fi

          if test "${CHANNEL_SAFE}" = "latest"; then
            RELEASE_TAG="${{ github.ref_name }}"
          else
            RELEASE_TAG="v${VER}-${CHANNEL_SAFE}.${{ github.run_number }}"
          fi

          VER_INT=$(echo "${VER}" | awk -F. '{printf "%d\n", sprintf("%03d%03d%03d", $1, $2, $3)}')

          echo "full_version=${RELEASE_TAG}" >> "${GITHUB_OUTPUT}"
          echo "version=${VER}" >> "${GITHUB_OUTPUT}"
          echo "version_int=${VER_INT}" >> "${GITHUB_OUTPUT}"
          echo "update_channel=${CHANNEL_SAFE}" >> "${GITHUB_OUTPUT}"
      - name: Checkout
        uses: actions/checkout@v6
        with:
          submodules: true
          fetch-depth: 1
          ref: ${{ github.ref }}
      - name: Get EMSDK version
        id: get_emsdk_version
        working-directory: "third_party/emsdk"
        run: |
          git fetch --unshallow
          echo "emsdk_version=$(git describe --tags --abbrev=0)" >> "${GITHUB_OUTPUT}"
      - name: Versioning
        run: |
          sed -i "s|/\* COLOPL_VERSION_START \*/.*/\* COLOPL_VERSION_END \*/|${{ steps.generate_version.outputs.version_int }}|" "library/include/colopresso.h"
          sed -i "s|VERSION 0.0.0|VERSION ${{ steps.generate_version.outputs.version }}|" "CMakeLists.txt"
          sed -i "s|0.0.0|${{ steps.generate_version.outputs.version }}|" "app/chrome/manifest.json"
          sed -i "s|0.0.0|${{ steps.generate_version.outputs.version }}|" "package.json"
          sed -i "s|\"channel\": \"[^\"]*\"|\"channel\": \"${{ steps.generate_version.outputs.update_channel }}\"|" "package.json"
      - name: Apply update channel
        if: ${{ steps.generate_version.outputs.update_channel != 'latest' }}
        run: |
          CHANNEL="${{ steps.generate_version.outputs.update_channel }}"
          PKG="package.json"

          if test ! -f "${PKG}"; then
            echo "package.json not found at ${PKG}" >&2
            exit 1
          fi

          TMP="$(mktemp)"
          jq --arg channel "${CHANNEL}" '
            .build.publish as $p
            | if ($p | type) != "array" or ($p | length) == 0 then error("package.json is missing build.publish") else . end
            | .build.publish[0].channel = $channel
            | .build.publish[0].releaseType = "prerelease"
          ' "${PKG}" > "${TMP}"
          mv "${TMP}" "${PKG}"
      - name: Apply rename for non-latest channels
        if: ${{ steps.generate_version.outputs.update_channel != 'latest' }}
        run: |
          CHANNEL="${{ steps.generate_version.outputs.update_channel }}"
          PKG="package.json"

          if test ! -f "${PKG}"; then
            echo "package.json not found at ${PKG}" >&2
            exit 1
          fi

          TMP="$(mktemp)"
          jq --arg channel "${CHANNEL}" '
            .build as $b
            | if $b == null then error("package.json is missing build configuration") else . end
            | if $b.productName == null then error("package.json is missing build.productName") else . end
            | .build.productName = ($b.productName + "_" + $channel)
            ' "${PKG}" > "${TMP}"
            mv "${TMP}" "${PKG}"

      - name: Normalize update channel & set prerelease version
        if: ${{ steps.generate_version.outputs.update_channel != 'latest' }}
        run: |
          CHANNEL_RAW="${{ steps.generate_version.outputs.update_channel }}"
          CHANNEL_SAFE="$(printf '%s' "${CHANNEL_RAW}" | tr '[:upper:]' '[:lower:]' | tr '_' '-' | tr -cd '0-9a-z-')"
          if test -z "${CHANNEL_SAFE}"; then
            echo "Failed to normalize channel: ${CHANNEL_RAW}" >&2
            exit 1
          fi

          PKG="package.json"
          if test ! -f "${PKG}"; then
            echo "package.json not found at ${PKG}" >&2
            exit 1
          fi

          BASE_VERSION="${{ steps.generate_version.outputs.version }}"
          PRERELEASE_VERSION="${BASE_VERSION}-${CHANNEL_SAFE}.${{ github.run_number }}"

          TMP="$(mktemp)"
          jq --arg channel "${CHANNEL_SAFE}" --arg version "${PRERELEASE_VERSION}" '
            .version = $version
            | .build.publish as $p
            | if ($p | type) != "array" or ($p | length) == 0 then error("package.json is missing build.publish") else . end
            | .build.publish[0].channel = $channel
          ' "${PKG}" > "${TMP}"
          mv "${TMP}" "${PKG}"
      - name: Tar versioned code
        run: |
          tar -czf "../versioned-code.tar.gz" -C .. "$(basename "$PWD")"
          mv "../versioned-code.tar.gz" "./versioned-code.tar.gz"
      - name: Upload versioned code
        uses: actions/upload-artifact@v5
        with:
          name: versioned-code
          path: ./versioned-code.tar.gz
          retention-days: 1
  Source:
    needs: Prepare
    runs-on: ubuntu-24.04
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v6
        with:
          name: versioned-code
          path: .
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          rm -rf "versioned-code.tar.gz"
      - name: Create versioned source code
        run: |
          cp -a . "/tmp/colopresso"
          cd "/tmp/colopresso"
            rm -rf "build"
            rm -rf "third_party"
          cd -
          mkdir -p "${{ github.workspace }}/dist"
          tar -czf "${{ github.workspace }}/dist/colopresso_source.tar.gz" -C "/tmp" "colopresso"
      - name: Upload artifacts
        uses: actions/upload-artifact@v5
        with:
          name: colopresso-source
          path: dist/
  WindowsElectron:
    needs: Prepare
    strategy:
      matrix:
        channel:
          - ${{ needs.Prepare.outputs.update_channel }}
          - ${{ needs.Prepare.outputs.update_channel == 'latest' && 'colopl_internal' || 'colopl_internal_canary' }}
    runs-on: windows-latest
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v6
        with:
          name: versioned-code
          path: .
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          Remove-Item "versioned-code.tar.gz" -Force
      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0
        with:
          version: 10
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '24'
          cache: 'pnpm'
      - name: Override productName for internal channel
        if: ${{ matrix.channel == 'colopl_internal' || matrix.channel == 'colopl_internal_canary' }}
        shell: pwsh
        run: |
          $pkgPath = "package.json"
          if (-not (Test-Path $pkgPath)) { Write-Error "package.json not found at $pkgPath"; exit 1 }

          $json = Get-Content $pkgPath -Raw | ConvertFrom-Json
          if (-not $json.build) { Write-Error "package.json is missing build configuration"; exit 1 }

          $rawChannel = "${{ matrix.channel }}"
          $safeChannel = $rawChannel.ToLower().Replace('_','-') -replace '[^0-9a-z-]', ''
          if (-not $safeChannel) { Write-Error "Failed to normalize channel: $rawChannel"; exit 1 }

          $baseVersion = "${{ needs.Prepare.outputs.version }}"
          $json.version = "${baseVersion}-$safeChannel.${{ github.run_number }}"
          $json.build.productName = "colopresso_${{ matrix.channel }}"
          $json.build.publish[0].channel = $safeChannel
          $json | ConvertTo-Json -Depth 64 | Set-Content $pkgPath -Encoding UTF8
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@0b1efabc08b657293548b77fb76cc02d26091c7e
        with:
          toolchain: stable
          targets: wasm32-unknown-emscripten
      - name: Setup emsdk
        shell: pwsh
        working-directory: "third_party/emsdk"
        run: |
          ./emsdk.ps1 install "${{ needs.Prepare.outputs.emsdk_version }}"
          ./emsdk.ps1 activate "${{ needs.Prepare.outputs.emsdk_version }}"
          . "./emsdk_env.ps1"
          Get-ChildItem env: | Where-Object { $_.Name -match '^(EMSDK|EM_|BINARYEN)' } | ForEach-Object {
            "$($_.Name)=$($_.Value)" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          }
          "$env:EMSDK" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          "$env:EMSDK\upstream\emscripten" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          "$env:EMSDK\node\$(Get-ChildItem "$env:EMSDK\node" | Select-Object -First 1 -ExpandProperty Name)_64bit\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
      - name: Build Electron app
        shell: pwsh
        run: |
          if ("${{ matrix.channel }}" -eq "colopl_internal" -or "${{ matrix.channel }}" -eq "colopl_internal_canary") {
              $env:WIN_CSC_LINK = "${{ secrets.WINDOWS_CERTIFICATE_BASE64 }}"
              $env:WIN_CSC_KEY_PASSWORD = "${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}"
          }

          emcmake cmake -B "build" -DCOLOPRESSO_ELECTRON_APP=ON -DCOLOPRESSO_ELECTRON_TARGETS="--win"
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
          cmake --build "build" --config "Release" --parallel
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Copy artifacts
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path "dist" | Out-Null
          Get-ChildItem -Path "dist_build" -Include "*.exe","*.yml","*.blockmap" -Recurse -File | ForEach-Object {
            Copy-Item $_.FullName -Destination "dist\"
          }
      - name: Upload artifacts
        uses: actions/upload-artifact@v5
        with:
          name: colopresso-electron-windows-${{ matrix.channel }}
          path: dist/
          if-no-files-found: error
  macOSElectron:
    needs: Prepare
    runs-on: macos-latest
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v6
        with:
          name: versioned-code
          path: .
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          rm -rf "versioned-code.tar.gz"
      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0
        with:
          version: 10
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '24'
          cache: 'pnpm'
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@0b1efabc08b657293548b77fb76cc02d26091c7e
        with:
          toolchain: stable
          targets: wasm32-unknown-emscripten
      - name: Setup emsdk
        working-directory: "third_party/emsdk"
        run: |
          ./emsdk install "${{ needs.Prepare.outputs.emsdk_version }}"
          ./emsdk activate "${{ needs.Prepare.outputs.emsdk_version }}"
          . "./emsdk_env.sh"
          env | grep -E '^(EMSDK|EM_|BINARYEN)' | while IFS='=' read -r key value; do
            echo "${key}=${value}" >> "${GITHUB_ENV}"
          done
          echo "${EMSDK}" >> "${GITHUB_PATH}"
          echo "${EMSDK}/upstream/emscripten" >> "${GITHUB_PATH}"
          echo "${EMSDK}/node/$(ls "${EMSDK}/node" | head -n 1)_64bit/bin" >> "${GITHUB_PATH}"
      - name: Detect macOS signing configuration
        id: macos_signing
        shell: bash
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
        run: |
          HAS_CERT=false
          HAS_NOTARY=false

          if test -n "${MACOS_CERTIFICATE}" && test -n "${MACOS_CERTIFICATE_PWD}"; then
            HAS_CERT=true
          fi

          if test -n "${APPLE_API_KEY}" && test -n "${APPLE_API_KEY_ID}" && test -n "${APPLE_API_ISSUER}"; then
            HAS_NOTARY=true
          fi

          echo "HAS_CERT=${HAS_CERT}" >> "${GITHUB_OUTPUT}"
          echo "HAS_NOTARY=${HAS_NOTARY}" >> "${GITHUB_OUTPUT}"

          if test "${HAS_CERT}" != "true"; then
            echo "CSC_IDENTITY_AUTO_DISCOVERY=false" >> "${GITHUB_ENV}"
          fi
      - name: Prepare Apple API Key for notarization
        id: prepare_apple_key
        if: ${{ steps.macos_signing.outputs.HAS_NOTARY == 'true' }}
        env:
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
        run: |
          mkdir -p "${RUNNER_TEMP}/private_keys"
          key_path="${RUNNER_TEMP}/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8"
          printf '%s' "${APPLE_API_KEY}" > "${key_path}"
          chmod 600 "${key_path}"
          echo "key_path=${key_path}" >> "${GITHUB_OUTPUT}"
      - name: Build Electron app (signed & notarized)
        run: |
          if test "${HAS_CERT}" = "true"; then
            export CSC_LINK="${MACOS_CERTIFICATE}"
            export CSC_KEY_PASSWORD="${MACOS_CERTIFICATE_PWD}"
          else
            unset CSC_LINK
            unset CSC_KEY_PASSWORD
            export CSC_IDENTITY_AUTO_DISCOVERY=false
          fi

          if test "${HAS_NOTARY}" = "true"; then
            export APPLE_API_KEY="${NOTARY_KEY_PATH}"
            export APPLE_API_KEY_ID="${APPLE_API_KEY_ID}"
            export APPLE_API_ISSUER="${APPLE_API_ISSUER}"
          else
            unset APPLE_API_KEY
            unset APPLE_API_KEY_ID
            unset APPLE_API_ISSUER
          fi

          emcmake cmake -B "build" -DCOLOPRESSO_ELECTRON_APP=ON -DCOLOPRESSO_ELECTRON_TARGETS="--mac" && \
          cmake --build "build" --config "Release" --parallel
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HAS_CERT: ${{ steps.macos_signing.outputs.HAS_CERT }}
          HAS_NOTARY: ${{ steps.macos_signing.outputs.HAS_NOTARY }}
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          NOTARY_KEY_PATH: ${{ steps.prepare_apple_key.outputs.key_path }}
      - name: Clean up Apple API Key
        if: ${{ always() && steps.macos_signing.outputs.HAS_NOTARY == 'true' }}
        env:
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
        run: rm -f "${RUNNER_TEMP}/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8"
      - name: Copy artifacts
        run: |
          mkdir -p "dist"
          find "dist_build" -type f \( -name '*.dmg' -o -name '*.dmg.blockmap' -o -name '*.zip' -o -name '*.zip.blockmap' -o -name '*.yml' \) \
            -exec cp {} "dist/" \;
      - name: Upload artifacts
        uses: actions/upload-artifact@v5
        with:
          name: colopresso-electron-macos
          path: dist/
          if-no-files-found: error
  ChromeExtension:
    needs: Prepare
    runs-on: ubuntu-24.04
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v6
        with:
          name: versioned-code
          path: .
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          rm -rf "versioned-code.tar.gz"
      - name: Setup builder
        run: |
          docker build \
            --file Dockerfile \
            --tag "chrome" \
            --build-arg ENABLE_VALGRIND=0 \
            --build-arg ENABLE_CLANG=0 \
            --build-arg ENABLE_EMSDK=1 \
            --build-arg EMSDK_VERSION="${{ needs.Prepare.outputs.emsdk_version }}" \
            --target base \
            .
      - name: Build Chrome Extension
        run: |
          docker run \
            --rm \
            --volume "${PWD}:/workspace" \
            --workdir "/workspace" \
            chrome \
            /bin/bash -lc '
              rm -rf "build" && \
              emcmake cmake -B "build" \
                -DCMAKE_BUILD_TYPE="Release" \
                -DCOLOPRESSO_CHROME_EXTENSION=ON && \
              cmake --build "build" --config "Release" --parallel="$(($(nproc)-1))"
            '
          mkdir -p "dist"
          tar -czf "dist/colopresso_chrome.tar.gz" -C "${PWD}/build" "chrome"
      - name: Upload artifacts
        uses: actions/upload-artifact@v5
        with:
          name: colopresso-chrome-extension
          path: dist/
  WindowsCLI:
    needs: Prepare
    strategy:
      matrix:
        runs-on:
          - windows-latest
          - windows-11-arm
        channel:
          - latest
          - ${{ needs.Prepare.outputs.update_channel }}
    runs-on: ${{ matrix.runs-on }}
    env:
      COLOPRESSO_CLI_EXE: 'build\cli\Release\colopresso.exe'
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v6
        with:
          name: versioned-code
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          Remove-Item "versioned-code.tar.gz" -Force
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@0b1efabc08b657293548b77fb76cc02d26091c7e
        with:
          toolchain: stable
      - name: Configure CMake
        run: cmake -B build -DCMAKE_BUILD_TYPE="Release" -DCOLOPRESSO_USE_CLI=ON
      - name: Build
        run: cmake --build "build" --config "Release" --target colopresso_cli --parallel
      - name: Test
        run: ctest --test-dir "build" --build-config "Release" --output-on-failure
      - name: Check CLI
        shell: pwsh
        run: |
          & "${env:COLOPRESSO_CLI_EXE}" --version
      - name: Sign binary
        shell: pwsh
        if: matrix.channel != 'latest'
        env:
          WIN_CSC_LINK: ${{ secrets.WINDOWS_CERTIFICATE_BASE64 }}
          WIN_CSC_KEY_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: |
          $exePath = "${env:COLOPRESSO_CLI_EXE}"

          if ($env:WIN_CSC_LINK) {
            Write-Host "Certificate found, creating signed internal binary..."
            $certBytes = [Convert]::FromBase64String($env:WIN_CSC_LINK)
            $certPath = "$env:RUNNER_TEMP\certificate.pfx"
            [IO.File]::WriteAllBytes($certPath, $certBytes)

            $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\" -Recurse -Filter "signtool.exe" | Where-Object { $_.FullName -match "x64" } | Select-Object -First 1 -ExpandProperty FullName
            & $signtool sign /f "$certPath" /p "$env:WIN_CSC_KEY_PASSWORD" /fd sha256 "$exePath"

            Remove-Item "$certPath" -Force
            Write-Host "Signed internal binary generated"
          } else {
            Write-Host "No certificate found, skipping signing"
          }
      - name: Prepare artifact
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path "dist" | Out-Null
          Copy-Item "${env:COLOPRESSO_CLI_EXE}" "dist/colopresso_windows_cli_${{ matrix.runs-on == 'windows-11-arm' && 'arm64' || 'x64' }}${{ matrix.channel != 'latest' && format('_{0}', matrix.channel) || '' }}.exe"
      - name: Upload artifact
        uses: actions/upload-artifact@v5
        with:
          name: colopresso-cli-windows-${{ matrix.runs-on == 'windows-11-arm' && 'arm64' || 'x64' }}-${{ matrix.channel }}
          path: dist/
          if-no-files-found: error
  macOSCLI:
    needs: Prepare
    strategy:
      matrix:
        arch:
          - name: apple_silicon
            rust_target: aarch64-apple-darwin
            runs-on: macos-15
          - name: intel
            rust_target: x86_64-apple-darwin
            runs-on: macos-15-intel
    runs-on: ${{ matrix.arch.runs-on }}
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v6
        with:
          name: versioned-code
          path: .
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          rm -rf "versioned-code.tar.gz"
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@0b1efabc08b657293548b77fb76cc02d26091c7e
        with:
          toolchain: stable
          targets: ${{ matrix.arch.rust_target }}
      - name: Detect macOS CLI signing configuration
        id: macos_cli_signing
        shell: bash
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
        run: |
          HAS_CERT=false
          HAS_NOTARY=false

          if test -n "${MACOS_CERTIFICATE}" && test -n "${MACOS_CERTIFICATE_PWD}"; then
            HAS_CERT=true
          fi

          if test -n "${APPLE_API_KEY}" && test -n "${APPLE_API_KEY_ID}" && test -n "${APPLE_API_ISSUER}"; then
            HAS_NOTARY=true
          fi

          echo "HAS_CERT=${HAS_CERT}" >> "${GITHUB_OUTPUT}"
          echo "HAS_NOTARY=${HAS_NOTARY}" >> "${GITHUB_OUTPUT}"
      - name: Configure CMake
        run: |
          cmake -B build \
            -DCMAKE_BUILD_TYPE="Release" \
            -DCOLOPRESSO_USE_CLI=ON \
            -DCOLOPRESSO_USE_TESTS=ON \
            ${{ matrix.arch.name == 'intel' && '-DAOM_TARGET_CPU=generic' || '' }}
      - name: Build
        run: cmake --build "build" --config "Release" --parallel
      - name: Check CLI
        run: ./build/cli/colopresso --version
      - name: Sign and notarize binary
        env:
          HAS_CERT: ${{ steps.macos_cli_signing.outputs.HAS_CERT }}
          HAS_NOTARY: ${{ steps.macos_cli_signing.outputs.HAS_NOTARY }}
          CSC_LINK: ${{ steps.macos_cli_signing.outputs.HAS_CERT == 'true' && secrets.MACOS_CERTIFICATE || '' }}
          CSC_KEY_PASSWORD: ${{ steps.macos_cli_signing.outputs.HAS_CERT == 'true' && secrets.MACOS_CERTIFICATE_PWD || '' }}
          APPLE_API_KEY: ${{ steps.macos_cli_signing.outputs.HAS_NOTARY == 'true' && secrets.APPLE_API_KEY || '' }}
          APPLE_API_KEY_ID: ${{ steps.macos_cli_signing.outputs.HAS_NOTARY == 'true' && secrets.APPLE_API_KEY_ID || '' }}
          APPLE_API_ISSUER: ${{ steps.macos_cli_signing.outputs.HAS_NOTARY == 'true' && secrets.APPLE_API_ISSUER || '' }}
        run: |
          if test "${HAS_CERT}" = "true"; then
            echo "Certificate found, signing binary..."
            echo "${CSC_LINK}" | base64 --decode > certificate.p12
            security create-keychain -p actions build.keychain
            security default-keychain -s build.keychain
            security unlock-keychain -p actions build.keychain
            security import certificate.p12 -k build.keychain -P "${CSC_KEY_PASSWORD}" -T "/usr/bin/codesign"
            security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k actions build.keychain
            rm certificate.p12

            codesign --force --options runtime --sign "Developer ID Application" --timestamp "build/cli/colopresso"
            codesign --verify --verbose "build/cli/colopresso"
            echo "Binary signed successfully"
          else
            echo "No certificate found, skipping signing"
          fi

          if test "${HAS_NOTARY}" = "true"; then
            echo "API key found, notarizing binary..."
            mkdir -p "${RUNNER_TEMP}/private_keys"
            echo "${APPLE_API_KEY}" > "${RUNNER_TEMP}/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8"
            chmod 600 "${RUNNER_TEMP}/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8"

            ditto -c -k --keepParent "build/cli/colopresso" "colopresso.zip"
            xcrun notarytool submit "colopresso.zip" \
              --key "${RUNNER_TEMP}/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8" \
              --key-id "${APPLE_API_KEY_ID}" \
              --issuer "${APPLE_API_ISSUER}" \
              --wait

            rm "colopresso.zip"
            echo "Binary notarized successfully"
          else
            echo "No API key found, skipping notarization"
          fi
      - name: Clean up
        if: always()
        env:
          HAS_NOTARY: ${{ steps.macos_cli_signing.outputs.HAS_NOTARY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
        run: |
          if test "${HAS_NOTARY}" = "true"; then
            rm -f "${RUNNER_TEMP}/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8"
          fi
          security delete-keychain build.keychain 2>/dev/null || true
      - name: Prepare artifact
        run: |
          mkdir -p "artifact"
          cp "build/cli/colopresso" "artifact/colopresso-cli-macos-${{ matrix.arch.name }}"
      - name: Upload artifact
        uses: actions/upload-artifact@v5
        with:
          name: colopresso-cli-macos-${{ matrix.arch.name }}
          path: artifact/
          if-no-files-found: error
  LinuxCLI:
    needs: Prepare
    strategy:
      matrix:
        include:
          - arch: amd64
            runs-on: ubuntu-24.04
          - arch: arm64
            runs-on: ubuntu-24.04-arm
    runs-on: ${{ matrix.runs-on }}
    steps:
      - name: Download versioned code
        uses: actions/download-artifact@v6
        with:
          name: versioned-code
          path: .
      - name: Extract versioned code
        run: |
          tar -xzf "versioned-code.tar.gz" --strip-components=1
          rm -rf "versioned-code.tar.gz"
      - name: Build container
        run: |
          docker build \
            --file Dockerfile.alpine \
            --tag cli-${{ matrix.arch }} \
            .
      - name: Build CLI in container
        run: |
          docker run \
            --rm \
            --volume "${PWD}:/workspace" \
            --workdir "/workspace" \
            cli-${{ matrix.arch }} \
            sh -c '
              cmake -B build -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXE_LINKER_FLAGS="-static" -DCOLOPRESSO_USE_CLI=ON && \
              cmake --build build --config Release --target colopresso_cli --parallel=$(($(nproc)-1)) && \
              strip build/cli/colopresso && \
              build/cli/colopresso --version
            '
      - name: Test binary in minimal container
        run: |
          docker run \
            --rm \
            --volume "${PWD}/build/cli/colopresso:/colopresso:ro" \
            busybox:musl \
            /colopresso --version
      - name: Prepare artifact
        run: |
          mkdir -p "artifact"
          cp "build/cli/colopresso" "artifact/colopresso-cli-linux-${{ matrix.arch }}"
      - name: Upload artifact
        uses: actions/upload-artifact@v5
        with:
          name: colopresso-cli-linux-${{ matrix.arch }}
          path: artifact/
          if-no-files-found: error
  Release:
    needs:
      - Prepare
      - WindowsElectron
      - macOSElectron
      - ChromeExtension
      - Source
      - WindowsCLI
      - macOSCLI
      - LinuxCLI
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          submodules: false
          fetch-depth: 1
          ref: ${{ github.ref }}
      - name: Create Release
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${{ needs.Prepare.outputs.full_version }}" \
            --title "${{ needs.Prepare.outputs.version }}" \
            --generate-notes \
            --prerelease="${{ needs.Prepare.outputs.update_channel != 'latest' }}" \
            --draft=false
          for RETRY in {1..10}; do
            if gh release view "${{ needs.Prepare.outputs.full_version }}" > /dev/null 2>&1; then
              echo "Release is ready"
              gh release view "${{ needs.Prepare.outputs.full_version }}"
              break
            fi
            echo "Waiting for release to be available... (${RETRY}/10)"
            sleep 2
          done
      - name: Download Chrome Extension Artifacts
        uses: actions/download-artifact@v6
        with:
          name: colopresso-chrome-extension
          path: artifacts/
      - name: Download Source Artifacts
        uses: actions/download-artifact@v6
        with:
          name: colopresso-source
          path: artifacts/
      - name: Download Electron Artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: colopresso-electron-*
          merge-multiple: true
          path: artifacts/
      - name: Download CLI Artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: colopresso-cli-*
          merge-multiple: true
          path: artifacts/
      - name: Generate and upload checksums
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cd "artifacts"
          find . -type f -exec sh -c 'echo "$(sha256sum "$1" | cut -d" " -f1)  $(basename "$1")"' _ {} \; > "checksums.txt"
          gh release upload "${{ needs.Prepare.outputs.full_version }}" "checksums.txt" --clobber
      - name: Upload Release Assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          rm -rf "${{ github.workspace }}/artifacts/app-update.yml"
          rm -rf "${{ github.workspace }}/artifacts/builder-debug.yml"
          rm -rf "${{ github.workspace }}/artifacts/builder-effective-config.yaml"
          rm -rf "${{ github.workspace }}/artifacts/elevate.exe"
          for FILE in "${{ github.workspace }}/artifacts"/*; do
            if test -f "${FILE}"; then
              gh release upload "${{ needs.Prepare.outputs.full_version }}" "${FILE}" --clobber
            fi
          done
